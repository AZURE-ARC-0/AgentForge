# Agent Methods

Welcome to the Agent Methods documentation! In this section, we'll walk you through the key methods within the `Agent` base class which are the most relevant for creating [Custom Agents](CustomAgents.md). Understanding these methods will help you customize and extend the capabilities of your agents effectively.

---

## ðŸ“Œ Important Note: The Essence of Agents

All the methods outlined in this documentation serve a dual purpose:

1. **Customization & Specialization**: These methods act as access points for specialization. You can override them to implement specific functionalities without changing the entire code base. This allows each subclass to be a specialized version of the base `Agent` class, extending or modifying its behaviors.

2. **Default Behavior & Streamlining**: The methods also serve as the default behavior for any agent, making the creation of new agents incredibly streamlined. Just create a new subclass of the `Agent` class, add its prompts, and you're good to go!

In other words, The `Agent` base class serves as a generic agent, while each subclass is a specialized agent.

For more details on how to create and specialize agents, see [Custom Agents](CustomAgents.md).

---

## Methods
1. [Run](#run)
2. [Load Data](#load-data)
3. [Load Agent Data](#load-agent-data)
4. [Load Agent Type Data](#load-agent-type-data)
5. [Load Additional Data](#load-additional-data)
6. [Load Persona Data](#load-persona-data)
7. [Process Data](#process-data)
8. [Generate Prompt](#generate-prompt)
9. [Run LLM](#run-llm)
10. [Parse Result](#parse-result)
11. [Save Result](#save-result)
12. [Build Output](#build-output)
13. [Additional Functions](#note-additional-functions)

---

## Run

### `run(**kwargs)`

**Purpose**: This method orchestrates the execution of the agent's workflow, encompassing the sequence of loading data, processing it, generating prompts, running language models, parsing results, saving those results, and ultimately constructing the output. It incorporates robust error handling to ensure smooth operation throughout this workflow.

**Arguments**:
- `**kwargs`: Additional keyword arguments that may be utilized during the data loading phase.

**Workflow**:
1. Log the start of the run process with the agent's name.
2. Load data by invoking `self.load_data(**kwargs)`.
3. Process the loaded data through `self.process_data()`.
4. Generate the prompt for the language model using `self.generate_prompt()`.
5. Execute the language model task with `self.run_llm()`.
6. Parse the result obtained from the language model with `self.parse_result()`.
7. Save the parsed result via `self.save_result()`.
8. Build the final output using `self.build_output()`.
9. Log the completion of the process.
10. Return the built output or `None` if an exception occurs during execution.

**Error Handling**:
- The method includes a `try-except` block to catch and log any exceptions that occur during the execution of the agent's workflow. If an error is encountered, the method logs the error and returns `None`, indicating that the process did not complete successfully.

**Code Example**:

```python
def run(self, **kwargs):
    """
    Orchestrates the execution of the agent's workflow: loading data, processing data, generating prompts,
    running language models, parsing results, saving results, and building the output.

    Parameters:
        **kwargs: Keyword arguments that can be used for loading data.

    Returns:
        The output generated by the agent or None if an error occurred during execution.
    """
    try:
        self.logger.log(f"\n{self.agent_name} - Running...", 'info')
        self.load_data(**kwargs)
        self.process_data()
        self.generate_prompt()
        self.run_llm()
        self.parse_result()
        self.save_result()
        self.build_output()
        self.logger.log(f"\n{self.agent_name} - Done!", 'info')
    except Exception as e:
        self.logger.log(f"Error running agent: {e}", 'error')
        return None

    return self.output
```
---

## Load Data

### `load_data(self, **kwargs)`

**Purpose**: This method centralizes the data loading process for the agent. It is designed to orchestrate the loading of various types of data, including agent-specific data, persona data, type-specific data, and any additional data. This ensures a comprehensive and structured approach to populating the agent's internal `data` attribute with all necessary information required for its operation.

**Arguments**:
- `**kwargs`: These are additional keyword arguments that facilitate further customization and flexibility in data loading. These arguments are passed to relevant loading methods to accommodate specific data requirements or preferences at runtime including data for prompt rendering.

**Workflow**:
1. **Agent Data Loading**: Initiates with `self.load_agent_data(**kwargs)`, which loads data inherent to the agent itself. This includes processing any additional information provided via `**kwargs`, allowing for dynamic configuration of the agent based on runtime inputs.
2. **Persona Data Loading**: Proceeds with `self.load_persona_data()`, a step specific to loading persona-related data. This is particularly important for agents that have or require a persona for their operation, ensuring they have the necessary context or characteristics defined.
3. **Type-Specific Data Loading**: Continues with `self.load_agent_type_data()`, focusing on loading data that is specific to the agent's type or category. This ensures that agents can have their unique operational data loaded, which is essential for their specialized functionalities, this is intended for multi-generation inheritance of agent classes.
4. **Additional Data Loading**: Concludes with `self.load_additional_data()`, which is aimed at incorporating any extra data that may be specific to the agent's unique requirements or tasks. This step allows for the inclusion of bespoke data that enhances the agent's operations.

**Code Example**:

```python
def load_data(self, **kwargs):
    """
    Central method for data loading that orchestrates the loading of agent data, type-specific data, main data,
    and any additional data.

    Parameters:
        **kwargs: Keyword arguments for additional data loading.
    """
    self.load_agent_data(**kwargs)
    self.load_persona_data()
    self.load_agent_type_data()
    self.load_additional_data()
```
---

## Load Agent Data

### `load_agent_data(self, **kwargs)`

**Purpose**: This method is tasked with loading data specific to the agent, including configurations such as parameters and prompts. It efficiently merges these configurations with any additional data provided through `**kwargs`, ensuring the agent's internal `data` attribute is comprehensively populated for its operation.

**Arguments**:
- `**kwargs`: Additional keyword arguments that are merged into the agent's data, providing a flexible mechanism for extending or customizing the agent's configuration at runtime.

**Workflow**:
1. **Agent Configuration Data Loading**: Starts by fetching the agent's configuration data, including parameters and prompt templates, using `self.functions.agent_utils.load_agent_data(self.agent_name)`. This foundational data is crucial for defining the agent's operational context and capabilities.
2. **Data Structure Initialization**: Initializes the agent's internal `data` attribute with two key components:
   - `params`: A copy of the agent's parameters, ensuring any setting overrides are applied on top of the default configuration.
   - `prompts`: A copy of the agent's prompt templates, which are essential for guiding the agent's interactions or tasks.
3. **Additional Data Integration**: Iterates through `**kwargs` to seamlessly integrate any supplementary data provided at runtime into the `data` attribute. This approach allows for dynamic adjustment of the agent's data according to specific needs or contexts.
4. **Error Handling**: Incorporates error handling to log any issues encountered during the data loading process. If an error occurs, it logs the error ensuring the agent does not proceed with incomplete or erroneous data.

**Code Example**:

```python
def load_agent_data(self, **kwargs):
    """
    Loads the agent's configuration data including parameters and prompts, merging them with any additional data
    provided through kwargs.

    Parameters:
        **kwargs: Additional keyword arguments to be merged into the agent's data.
    """
    try:
        self.agent_data = self.functions.agent_utils.load_agent_data(self.agent_name)
        self.data = {'params': self.agent_data.get('params').copy(), 'prompts': self.agent_data['prompts'].copy()}
        for key in kwargs:
            self.data[key] = kwargs[key]
    except Exception as e:
        self.logger.log(f"Error loading agent data: {e}", 'error')
```
---

## Load Agent Type Data

### `load_agent_type_data(self)`

**Purpose**: This method acts as a foundational mechanism within the architecture of agent subclasses, designed to enable the loading of type-specific data. It provides a systematic approach for enriching agents with functionalities and data peculiar to their specific type or category within a hierarchical agent system. This method is pivotal for ensuring that subclasses of the main `Agent` class can incorporate unique data requirements seamlessly alongside inherited functionalities.

**Example Use Case**: For instance, within a subclass such as `TaskAgent`, this method can be specialized to include data loading procedures and logic unique to task-based agents (like `TaskExecutionAgent`, `TaskVerificationAgent`, etc.). Such specialization ensures that all derived agents not only inherit the general capabilities of the broader `Agent` class but are also automatically equipped with task-specific data crucial for their operation.

**Arguments**: None. This method is designed to be self-contained, requiring no external input to execute its data loading routines, simplifying the process of subclassing and data management across different types of agents.

**Workflow**:
1. **Subclass Implementation**: In its default state, the method does not perform any operations. It is intended as a template to be overridden by subclasses, where specific data loading logic relevant to the subclass can be implemented. This design choice fosters modularity and encourages the development of well-structured agent hierarchies.

**Code Example**:
```python
def load_agent_type_data(self):
    """
    Placeholder for loading data specific to the agent's type. Meant to be overridden by custom agent types as
    needed.
    """
    pass
```

> **Note**: It is highly recommended to leverage this method within any subclass of the `Agent` to incorporate type-specific data. This practice not only enhances code reuse and efficiency but also maintains a streamlined and organized codebase, where functionalities specific to certain agent categories are neatly encapsulated within their respective subclass implementations.

---

## Load Additional Data

### `load_additional_data(self)`

**Purpose**: Tailored for the intricacies of final, specialized agent classes within the hierarchy, this method offers a dedicated avenue for loading bespoke data crucial to an agent's unique operational needs. It serves as a customizable point for agents to incorporate specific data sets that are pivotal for their designated tasks and functionalities, ensuring a high degree of specialization and effectiveness in their execution.

**Example Use Case**: In the context of diverse operational needsâ€”be it a `WeatherReportingAgent` requiring detailed meteorological data or a `StockAnalysisAgent` in need of up-to-the-minute financial market insightsâ€”this method stands ready to be overridden to fulfill those specific data requisites.

**Arguments**: None. The design of this method intentionally requires no arguments, emphasizing its role as a customizable hook for specialized data loading without imposing predefined data parameters.

**Workflow**:
1. **Customization Framework**: By default, this method is intentionally left unimplemented (i.e., it performs no operations). This design decision establishes it as a conceptual template for developers to override within their final agent classes, enabling the incorporation of unique data loading logic tailored to the agent's specific needs and functionalities.

**Code Example**:
```python
def load_additional_data(self):
    """
    Placeholder for loading additional data. Meant to be overridden by custom agents as needed.
    """
    pass
```

> **Note**: Emphasizing its significance in the architecture of task-specific agents, the `load_additional_data` method embodies the principle of flexibility and customization at the core of agent design. Developers are encouraged to leverage this method to equip their agents with the unique datasets and information critical for executing their specialized tasks, thus maximizing the agents' effectiveness and adaptability across a wide range of scenarios.

---

## Load Persona Data

### `load_persona_data(self)`

**Purpose**: This method enriches agents with persona-specific knowledge, allowing them to access and utilize personality traits, general knowledge, or any other information defined in their persona configuration. The method seamlessly loads this data from a YAML file, making it effortless to imbue agents with a rich, dynamic personality without hard-coding details into the agent's codebase. This flexibility facilitates the creation of more engaging and context-aware agents capable of delivering personalized interactions.

**How It Works**: Persona data is structured in a YAML file, from which this method retrieves information and stores it within the agent's internal `data` attribute. Key-value pairs defined in the persona file become accessible to the agent, enabling their use in prompt templates and other operations.

**Case Insensitivity and Variable Referencing**: When incorporating persona data into prompt templates, it's essential to reference variables in lowercase, regardless of their case in the persona YAML file. This design ensures uniformity and simplifies the template creation process, making it more intuitive for developers to craft dynamic and contextually relevant prompts.

**Example Persona YAML File**:
```yaml
# botty.yaml
Name: Botty McBotFace
Description: |+
    a generic bot

Location: Dinner Table
Purpose: Pass the butter
```

**Integrating Persona Data into Prompts**:
To utilize persona data within prompts, reference the corresponding variables in the agent's prompt YAML file as shown below. This approach allows for dynamic content generation based on the loaded persona data, enhancing the agent's ability to deliver personalized and engaging content.

**Prompt YAML File Example**:
```yaml
Prompts:
    System: |+
        Your name is {name}. You are {description}.
        Your location: {location}. 
        Your sole purpose is as follows: {purpose}.

Persona: botty # Optional Parameter: This overrides the default persona set by system
```

**Rendered Prompt Example**:
```
Your name is Botty McBotFace. You are a generic bot.
Your location: Dinner Table. 
Your sole purpose is as follows: Pass the butter.
```

**Code Example**:
```python
def load_persona_data(self):
    """
    Loads the persona data for the agent if available.
    """
    persona = self.agent_data.get('persona', None)
    if persona:
        for key in persona:
            self.data[key.lower()] = persona[key]
```

---

> **Note**: The versatility of the `load_persona_data` method allows for the creation of one or more persona files not only for crafting rich, persona-driven experiences but also as a repository for any kind of static data or knowledge that an agent may need, which isn't subject to frequent changes. While it excels in defining personalities for NPCs or similar entities, its utility extends beyond character traits to encompass a wide range of information, such as historical facts, scientific data, or any kind of general knowledge. This flexibility makes it an invaluable asset for developers looking to enrich their agents with a depth of information, all without the need for constant code adjustments. By simply modifying or expanding the persona file, developers can seamlessly integrate new knowledge into their agent's repertoire, enhancing both the functionality and the engagement level of their interactions.

---

## Process Data

### `process_data(self)`

**Purpose**: This method acts as a scaffold for any data processing that needs to occur before data is utilized within the agent. It's intentionally left empty to be customized by developers according to the unique processing requirements of their custom agents. The flexibility here allows for a wide range of preprocessing tasks, such as data normalization, filtering, or augmentation, tailored to enhance the agent's performance or output quality.

**Arguments**: None

```python
def process_data(self):
    """
    Placeholder for data processing. Meant to be overridden by custom agents for specific data processing needs.
    """
    pass
```

> **Note**: This method is strategically designed for extension by developers crafting [Custom Agents](CustomAgents.md). By overriding `process_data`, developers can inject bespoke processing logic, ensuring their agents can interpret and handle data in the most effective way possible. This customization capability underscores the framework's adaptability to diverse applications, from simple data manipulation to complex preprocessing pipelines.
---

## Generate Prompt

### `generate_prompt(self)`

**Purpose**: This method plays a crucial role in preparing the prompts for the language model, crafting them based on specific templates and the data loaded into the agent. It ensures that each prompt is meticulously generated to align with the agent's objectives and data context, thereby optimizing the interaction between the agent and the LLM.

**Workflow**:
1. Begin by creating an empty list named `rendered_prompts` to accumulate the generated prompts.
2. Loop through each `prompt_template` found in the agent's `data['prompts']` attribute.
3. Utilize the `handle_prompt_template` function to fetch and validate each prompt template.
4. Upon validation, the template is rendered with the agent's data to create a prompt.
5. Append the rendered prompt to the `rendered_prompts` list.
6. The list of `rendered_prompts` is then assigned to the agent's internal `prompt` attribute.
7. Implement error handling to catch and log exceptions, ensuring robustness in prompt generation.

```python
def generate_prompt(self):
    """
    Generates the prompt(s) for the language model based on template data. It handles the rendering of prompt
    templates and aggregates them into a list.
    """
    try:
        rendered_prompts = []
        for prompt_template in self.data['prompts'].values():
            template = self.functions.prompt_handling.handle_prompt_template(prompt_template, self.data)
            if template:
                rendered_prompt = self.functions.prompt_handling.render_prompt_template(template, self.data)
                rendered_prompts.append(rendered_prompt)
   
        self.prompt = rendered_prompts
    except Exception as e:
        self.logger.log(f"Error generating prompt: {e}", 'error')
        self.prompt = None
```

> **Note**: The generation of prompts relies on the structure and content of `YAML` files associated with each agent, stored in the `.agentforge/agents/` directory. The naming convention for these `YAML` files is critical for proper operation; they should match the name of their corresponding custom agent class.
> 
> **Example**: For a custom agent class named `WeatherAgent`, the corresponding `YAML` file should be `WeatherAgent.yaml`.
> 
> The inclusion of error handling in this method enhances the resilience of the agent, ensuring that any issues encountered during prompt generation are appropriately logged, and the process can safely continue or gracefully degrade.

---

## Run LLM

### `run_llm(self)`

**Purpose**: This crucial method is responsible for engaging the Large Language Model (LLM) to generate responses based on the previously rendered prompts. It leverages the agent's internal `prompt` attribute as input for the LLM. The output from the LLM is meticulously processed and stored within the agent's internal `result` attribute, ready for further use or analysis.

**Arguments**: None

**Workflow**:
1. Access the LLM instance stored within `self.agent_data['llm']`.
2. Retrieve any additional parameters designated for the LLM execution from `self.agent_data.get("params", {})`. The method now also dynamically adds the agent's name to the parameters.
3. Invoke the `generate_text` method on the LLM instance, passing in the `prompt` alongside the specified parameters.
4. Post-generation, the method trims any excess whitespace from the beginning and end of the generated text, ensuring a clean output is stored in `self.result`.
5. Implement error handling to catch and log exceptions, maintaining robust execution even in the face of errors during the LLM operation.

```python
def run_llm(self):
    """
    Executes the language model generation with the generated prompt(s) and any specified parameters,
    including dynamically added agent name for contextual relevance.
    """
    try:
    	model: LLM = self.agent_data['llm']
        params = self.agent_data.get("params", {})
        params['agent_name'] = self.agent_name  # Dynamically add agent name to the parameters
    	self.result = model.generate_text(self.prompt, **params).strip()
    except Exception as e:
    	self.logger.log(f"Error running LLM: {e}", 'error')
    	self.result = None
```

> **Note**: This method includes an error handling mechanism, ensuring that any issues encountered during the LLM execution are properly logged. This approach not only aids in debugging but also ensures that the agent can gracefully handle failures, maintaining the integrity of the application flow.

---

## Parse Result

### `parse_result(self)`

**Purpose**: The `parse_result` method serves as a foundational structure for developers to implement custom parsing logic for the responses generated by the LLM. This method is intentionally left as a no-operation (no-op) placeholder within the base agent class, providing a clear point of extension for custom behaviors.

**Arguments**: None

**Workflow**:
1. In its default state, this method does not perform any actions. Its primary role is to offer a structured opportunity for customization within the agent's lifecycle, specifically after receiving output from the LLM.

```python
def parse_result(self):
    """
    Placeholder for result parsing. This method is designed to be overridden by custom agents to incorporate
    specific logic for parsing and interpreting the results obtained from the LLM, tailored to the unique needs
    of the agent's operational context.
    """
    pass
```

> **Note**: [Custom Agents](CustomAgents.md) are encouraged to override this method to process and interpret the LLM's output according to their specific requirements. This could involve extracting relevant data, transforming the response into a more usable format, or integrating with other components of the agent's functionality. The design of this method as a customizable placeholder underscores the framework's flexibility, allowing developers to craft tailored agent behaviors that go beyond generic response handling.

---

## Save Result

### `save_result(self)`

**Purpose**: The `save_result` method is designed to preserve the outcomes generated by the LLM, effectively acting as the agent's mechanism for storing valuable information. This storage can be viewed as a form of memory for the agent, enabling it to recall and utilize results in future operations or decision-making processes.

**Arguments**: None

**Workflow**:
1. The method attempts to save the LLM-generated result into a predefined storage system. It specifies the collection name where the result should be stored and includes the result itself as part of the data to be saved.
2. It utilizes the `self.storage.save_memory` function, passing the `collection_name` as `Results` and the `data` as a list containing `self.result`.

```python
def save_result(self):
    """
    Saves the result of the language model generation into a specified storage. This method encapsulates the
    process of persisting generated results, allowing the agent to maintain a record of its interactions and
    outcomes. The flexibility of this storage mechanism supports the agent's ability to reference past results
    for future decision-making or to build upon previous interactions.
    """
    try:
        self.storage.save_memory(collection_name='Results', data=[self.result])
    except Exception as e:
        self.logger.log(f"Error saving result: {e}", 'error')
```

> **Note**: This method ensures that the agent's insights and outputs are not ephemeral, embedding a layer of memory into the agent's architecture. By storing results, developers can implement features that rely on historical data, enhance the agent's learning capabilities over time, or simply audit interactions. The method's design also emphasizes robustness, with error logging in place to capture and report any issues encountered during the save operation.

---

## Build Output

### `build_output(self)`

**Purpose**: The `build_output` method is responsible for assembling the agent's final output from the results obtained through the LLM's inference. In its basic form, this method equates the `self.output` with the `self.result`, effectively finalizing the agent's response to be delivered. This step is crucial as it marks the culmination of the agent's processing cycle, preparing the output for external use or further actions.

**Arguments**: None

**Workflow**:
1. Directly assigns the value of `self.result` to `self.output`, thereby establishing the agent's final output.

```python
def build_output(self):
    """
    Constructs the output from the result. This method serves as the final step in preparing the agent's response,
    making the generated result accessible as the official output. It is designed to be simple yet flexible,
    allowing for straightforward overrides by subclasses that may require a more intricate assembly of the output
    based on the agent's results or additional logic.
    """
    self.output = self.result
```

> **Note**: This method is intentionally designed with extensibility in mind, encouraging developers to customize the output formatting or content according to the unique needs of their [Custom Agents](CustomAgents.md). By overriding `build_output`, developers can tailor the agent's communication, enrich the response with additional information, or apply specific formatting required for the agent's operational context.

---

## Note: Additional Functions

While the key methods relevant for [Custom Agent](CustomAgents.md) creation have been covered in this section, the `Agent` class imports additional methods from a `Functions` utilities class. For those who want to dive deeper into its functionalities, a complete list and documentation of these extra methods can be found in the [Functions](../Utils/UtilsOverview.md) Page.

---